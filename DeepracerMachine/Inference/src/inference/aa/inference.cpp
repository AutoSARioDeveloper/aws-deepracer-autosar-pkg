///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : inference.cpp
/// SOFTWARE COMPONENT NAME           : Inference
/// GENERATED DATE                    : 2024-12-03 10:27:56
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "inference/aa/inference.h"
 
using namespace InferenceEngine;

namespace inference
{
namespace aa
{
 
Inference::Inference()
    : m_logger(ara::log::CreateLogger("INFE", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(2)
    , m_running(false)
{
}
 
Inference::~Inference()
{
}
 
bool Inference::Initialize()
{
    m_logger.LogVerbose() << "Inference::Initialize";
    
    bool init{true};
    
    m_PPortInference = std::make_shared<inference::aa::port::PPortInference>();
    m_RPortSensorFusion = std::make_shared<inference::aa::port::RPortSensorFusion>();
    
    return init;
}
 
void Inference::Start()
{
    m_logger.LogVerbose() << "Inference::Start";
    
    m_PPortInference->Start();
    m_RPortSensorFusion->Start();
    
    // run software component
    Run();
}
 
void Inference::Terminate()
{
    m_logger.LogVerbose() << "Inference::Terminate";

    m_running = false;

    m_PPortInference->Terminate();
    m_RPortSensorFusion->Terminate();
}
 
void Inference::Run()
{
    m_logger.LogVerbose() << "Inference::Run";

    m_running = true;

    m_workers.Async([this] { TaskReceiveSFEventCyclic(); });
    m_workers.Async([this] { HandleInferData(); });
    
    m_workers.Wait();
}

void Inference::TaskReceiveSFEventCyclic()
{
    m_logger.LogInfo() << "TaskReceiveSFEventCyclic: Setting ReceiveEventSFEventHandler";
    m_RPortSensorFusion->SetReceiveEventSFEventHandler([this](const auto& sample)
    {
        OnReceiveSFEvent(sample);
    });
    m_RPortSensorFusion->ReceiveEventSFEventCyclic();
}

bool Inference::IsValidSensorFusion(const std::shared_ptr<deepracer::serviceinterfacefusion::SensorFusion>& data)
{
    if (!data) {
        m_logger.LogError() << "SensorFusion data is null.";
        return false;
    }

    if (data->data.StereoCamera.left.height != 120) {
        m_logger.LogWarn() << "Invalid height: " << data->data.StereoCamera.left.height;
        return false;
    }

    if (data->data.SectorLidar.empty()) {
        m_logger.LogWarn() << "SectorLidar points are empty.";
        return false;
    }

    return true;
}

void Inference::OnReceiveSFEvent(const deepracer::service::sensorfusion::proxy::events::SFEvent::SampleType& sample)
{
    std::shared_ptr<deepracer::serviceinterfacefusion::SensorFusion> sfDataCopy;

    {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_latestSFData = std::make_shared<deepracer::serviceinterfacefusion::SensorFusion>(sample);
        sfDataCopy = m_latestSFData;
    }

    m_logger.LogInfo() << "Inference::OnReceiveSFEvent: Fusion data updated.";

    if (!sfDataCopy) {
        m_logger.LogError() << "m_latestSFData is null after copying.";
        return;
    }

    auto& sectorLidarData = sfDataCopy->data.SectorLidar;

    if (sectorLidarData.empty()) {
        m_logger.LogWarn() << "Sector Lidar data is empty.";
        return;
    }
}

void Inference::HandleInferData()
{
    const std::string modelPath = MODEL_PATH;

    Core ie;
    CNNNetwork network = ie.ReadNetwork(modelPath);
    if (network.getInputsInfo().empty() || network.getOutputsInfo().empty()) {
        m_logger.LogError() << "Failed to read the network: Invalid input or output info.";
        return;
    }

    auto inputInfo = network.getInputsInfo();
    auto outputInfo = network.getOutputsInfo();

    if (inputInfo.size() != 2 || outputInfo.size() != 1) {
        m_logger.LogError() << "Model does not match expected input/output configuration.";
        return;
    }

    std::string cameraInputName, lidarInputName, outputName;
    for (const auto& input : inputInfo) {
        if (input.first.find("STEREO_CAMERAS") != std::string::npos) {
            cameraInputName = input.first;
            input.second->setPrecision(Precision::U8);
        } else if (input.first.find("SECTOR_LIDAR") != std::string::npos) {
            lidarInputName = input.first;
            input.second->setPrecision(Precision::FP32);
        }
    }
    outputName = outputInfo.begin()->first;

    ExecutableNetwork executableNetwork = ie.LoadNetwork(network, "CPU"); 

    InferRequest inferRequest = executableNetwork.CreateInferRequest();
    if (!inferRequest) {
        m_logger.LogError() << "Failed to create an inference request.";
        return;
    }
    
    while (m_running) {
        if (!m_latestSFData) {
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            continue;
        }

        std::shared_ptr<deepracer::serviceinterfacefusion::SensorFusion> fusionData;

        {
            std::lock_guard<std::mutex> lock(m_mutex);
            fusionData = m_latestSFData;
            m_latestSFData.reset();
        }

        if (!fusionData) {
            m_logger.LogWarn() << "No fusion data available.";
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            continue;
        }

        Blob::Ptr cameraBlob = inferRequest.GetBlob(cameraInputName);
        auto cameraBlobData = cameraBlob ? cameraBlob->buffer().as<uint8_t*>() : nullptr;
        const auto& cameraImage = fusionData->data.StereoCamera.left;
        if (!cameraBlobData || cameraImage.width != 160 || cameraImage.height != 120) {
            m_logger.LogError() << "Invalid camera data or resolution.";
            continue;
        }
        std::memcpy(cameraBlobData, cameraImage.data.data(), cameraImage.data.size());

        const auto& lidarVectorBool = fusionData->data.SectorLidar;
        std::vector<float> lidarData(lidarVectorBool.begin(), lidarVectorBool.end());
        Blob::Ptr lidarBlob = inferRequest.GetBlob(lidarInputName);
        auto lidarBlobData = lidarBlob ? lidarBlob->buffer().as<float*>() : nullptr;
        if (!lidarBlobData) {
            m_logger.LogError() << "Invalid lidar data.";
            continue;
        }
        std::memcpy(lidarBlobData, lidarData.data(), lidarData.size() * sizeof(float));

        inferRequest.Infer();

        Blob::Ptr outputBlob = inferRequest.GetBlob(outputName);
        auto outputData = outputBlob->buffer().as<float*>();
        std::vector<float> outputResults(outputBlob->size());
        std::memcpy(outputResults.data(), outputData, outputBlob->size() * sizeof(float));

        deepracer::serviceinterfaceinfer::Inference inferData;
        inferData.timestamp = fusionData->timestamp;
        inferData.vehiclemode = fusionData->vehiclemode;

        for (size_t i = 0; i < outputResults.size(); ++i) {
            deepracer::inferenceitem::InferenceItem item;
            item.class_label = static_cast<int32_t>(i);
            item.class_prob = outputResults[i];
            inferData.data.push_back(item);
        }

        m_PPortInference->WriteDataInfEvent(inferData);
        m_PPortInference->SendEventInfEventTriggered();

        m_logger.LogInfo() << "Inference Results Sent.";
        for (const auto& item : inferData.data) {
            m_logger.LogInfo() << "Label : " << item.class_label
                               << ", Prob : " << item.class_prob;
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }
}

} /// namespace aa
} /// namespace inference

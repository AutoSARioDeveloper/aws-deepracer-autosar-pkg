///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : lidar.cpp
/// SOFTWARE COMPONENT NAME           : Lidar
/// GENERATED DATE                    : 2024-12-03 10:27:57
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "lidar/aa/lidar.h"

using namespace sl;

namespace lidar
{
namespace aa
{
 
Lidar::Lidar()
    : m_logger(ara::log::CreateLogger("LID", "SWC", ara::log::LogLevel::kVerbose))
    , scanIncrementDegree_(0.69)
    , minDegree_(-179)
    , maxDegree_(171)
    , minRange_(150)
    , maxRange_(1200)
    , sampleNum_(64)
    , sectorNum_(8)
    , m_workers(1)
    , m_running(false)
    , m_vehicleMode(VehicleMode::isDeepRacer)
{
}

 
Lidar::~Lidar()
{
}
 
bool Lidar::Initialize()
{
    m_logger.LogVerbose() << "Lidar::Initialize";
    
    bool init{true};
    
    m_PPortLidar = std::make_shared<lidar::aa::port::PPortLidar>();
    
    return init;
}
 
void Lidar::Start(VehicleMode mode)
{
    m_logger.LogVerbose() << "Lidar::Start";

    m_vehicleMode = mode;
    
    m_PPortLidar->Start();
    
    // run software component
    Run();
}
 
void Lidar::Terminate()
{
    m_logger.LogVerbose() << "Lidar::Terminate";
    
    m_running = false;

    m_PPortLidar->Terminate();
}
 
void Lidar::Run()
{
    m_logger.LogVerbose() << "Lidar::Run";

    m_running = true;

    m_workers.Async([this] { HandleLidar(); });

    m_workers.Wait();
}

bool Lidar::HandleLidar()
{
    if (m_vehicleMode == VehicleMode::isSimulation) {
        return HandleSimulationData();
    } else if (m_vehicleMode == VehicleMode::isDeepRacer) {
        return HandleDeepracerData();
    } else {
        m_logger.LogWarn() << "Invalid mode";
        return false;
    }
}

void Lidar::saveLidarData(std::vector<LidarStruct> &data, sl_lidar_response_measurement_node_hq_t *nodes, size_t count) {
    data.clear();
    for (size_t i = 0; i < count; ++i) {
        LidarStruct Lstruct;
        Lstruct.angle = (nodes[i].angle_z_q14 * 90.f) / 16384.f;
        Lstruct.distance = nodes[i].dist_mm_q2 / 4.0f;
        Lstruct.quality = nodes[i].quality >> SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT;
        data.push_back(Lstruct);
    }
}

std::vector<float> Lidar::linspace(float start, float end, float num) {
    if (num <= 0) return {};
    if (num == 1) return {start};

    std::vector<float> linspaced(num);
    float delta = (end - start) / (num - 1);
    for (int i = 0; i < num; ++i) {
        linspaced[i] = start + delta * i;
    }
    return linspaced;
}

std::vector<float> Lidar::interp(const std::vector<float>& sortedX, const std::vector<float>& sortedXp, const std::vector<float>& sortedFp) {
    size_t currXpIdx = 0;
    std::vector<float> returnArray;
    returnArray.reserve(sortedX.size());

    for (size_t currXidx = 0; currXidx < sortedX.size(); ++currXidx) {
        while (currXpIdx < sortedXp.size() - 1 && sortedX[currXidx] > sortedXp[currXpIdx + 1]) {
            ++currXpIdx;
        }
        if (currXpIdx >= sortedXp.size()) break;

        const float percent = (sortedX[currXidx] - sortedXp[currXpIdx]) /
                              (sortedXp[currXpIdx + 1] - sortedXp[currXpIdx]);
        returnArray.push_back(sortedFp[currXpIdx] * (1.0f - percent) + sortedFp[currXpIdx + 1] * percent);
    }
    return returnArray;
}

std::vector<float> Lidar::generateLidarData(const std::vector<float>& distanceList) {
    std::vector<float> lidarRanges, lidarDegrees;
    for (size_t i = 0; i < distanceList.size(); ++i) {
        float degree = minDegree_ + scanIncrementDegree_ * i;
        float range = std::isinf(distanceList[i]) ? maxRange_ : 
                      (distanceList[i] < minRange_ ? minRange_ : 
                      (distanceList[i] > maxRange_ ? maxRange_ : distanceList[i]));
        
        lidarRanges.push_back(range);
        lidarDegrees.push_back(degree);

        if (m_vehicleMode == VehicleMode::isDeepRacer && 
            (degree < minDegree_ || degree > maxDegree_)) {
            lidarRanges.pop_back();
            lidarDegrees.pop_back();
        }
    }

    auto desiredLidarDegrees = linspace(minDegree_, maxDegree_, sampleNum_);
    if (std::find(lidarDegrees.begin(), lidarDegrees.end(), minDegree_) == lidarDegrees.end()) {
        lidarDegrees.insert(lidarDegrees.begin(), minDegree_);
        lidarDegrees.push_back(maxDegree_);
        lidarRanges.insert(lidarRanges.begin(), maxRange_);
        lidarRanges.push_back(maxRange_);
    }

    std::lock_guard<std::mutex> guard(lidarMutex_);
    return interp(desiredLidarDegrees, lidarDegrees, lidarRanges);
}

std::vector<float> Lidar::generateSectorLidarData(const std::vector<float>& lidarInput, int sectorNum) {
    size_t blockSize;
    
    if (m_vehicleMode == VehicleMode::isDeepRacer) {
        blockSize = lidarInput.size() / sectorNum;
    } else if (m_vehicleMode == VehicleMode::isSimulation) {
        blockSize = (lidarInput.size() + sectorNum - 1) / sectorNum;
    } else {
        m_logger.LogWarn() << "Invalid mode";
        return {};
    }
    
    std::vector<float> sectorLidarData = binarySectorizeLidarData(lidarInput, blockSize);

    return sectorLidarData;
}


std::vector<float> Lidar::binarySectorizeLidarData(const std::vector<float>& lidarData, size_t blockSize) {
    std::vector<float> sectorLidarData;
    sectorLidarData.reserve((lidarData.size() + blockSize - 1) / blockSize);

    for (size_t i = 0; i < lidarData.size(); i += blockSize) {
        size_t endIdx = std::min(i + blockSize, lidarData.size());
        bool setBit = std::any_of(lidarData.begin() + i, lidarData.begin() + endIdx,
                                  [this](float value) { return value > minRange_; });
        sectorLidarData.push_back(setBit ? 1.0f : 0.0f);
    }

    if (m_vehicleMode == VehicleMode::isSimulation) {
        while (sectorLidarData.size() < sectorNum_) {
            sectorLidarData.push_back(0.0f);
        }
    }

    return sectorLidarData;
}


bool Lidar::HandleSimulationData()
{
    // ROS 토픽 구독 설정
    lidar_sub = nh.subscribe("/scan", 10, &Lidar::lidarCallback, this);

    m_logger.LogInfo() << "Lidar::HandleSimulationData - Start LiDAR Data Handling";

    // ROS 콜백 루프 실행
    while (m_running) {
        ros::spinOnce();  // ROS 콜백 함수 실행
        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }

    m_logger.LogInfo() << "Lidar::HandleSimulationData - Stopping LiDAR Data Handling";
    return true;
}

void Lidar::lidarCallback(const sensor_msgs::LaserScan::ConstPtr& msg)
{
    m_logger.LogInfo() << "LiDAR Callback - Received Data Count: " << msg->ranges.size();

    std::vector<LidarStruct> scanData;

    for (size_t i = 0; i < msg->ranges.size(); ++i) {
        float angle = msg->angle_min + i * msg->angle_increment;
        float distance = std::isinf(msg->ranges[i]) ? 0 : msg->ranges[i] * 1000; // m → mm

        // m_logger.LogInfo() << "Range[" << i << "]: " << msg->ranges[i] << ", Converted Distance: " << distance;

        LidarStruct Lstruct;
        Lstruct.angle = angle * 180 / M_PI; // 라디안 → 도(degree)
        Lstruct.distance = distance;
        Lstruct.quality = 47; // Q 값 고정
        scanData.push_back(Lstruct);
    }

    std::vector<float> distances;
    for (const auto& Lstruct : scanData) {
        distances.push_back(Lstruct.distance);
    }

    auto lidarData = generateLidarData(distances);
    auto sectorLidarData = generateSectorLidarData(lidarData, sectorNum_);

    // m_logger.LogInfo() << "Processed Sector Data:";
    // for (size_t i = 0; i < sectorLidarData.size(); ++i) {
    //     m_logger.LogInfo() << "Sector[" << i << "]: " << sectorLidarData[i];
    // }

    // 데이터 전송
    deepracer::lidardatalist::SectorLidarData convertedSectorData;
    for (const auto& value : sectorLidarData) {
        convertedSectorData.push_back(value);
    }

    deepracer::serviceinterfacelidar::SectorLidar data;
    data.data = convertedSectorData;
    data.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
                         std::chrono::system_clock::now().time_since_epoch())
                         .count();
    data.vehiclemode = toUint16(m_vehicleMode);

    size_t activeSectors = std::count_if(data.data.begin(), data.data.end(), [](float val) { return val > 0; });

    // m_logger.LogInfo() << "Lidar::WriteDataLidEvent - Active Sectors: " << activeSectors;
    m_PPortLidar->WriteDataLidEvent(data);
    // for (size_t i = 0; i < data.data.size(); ++i) {
    //     m_logger.LogInfo() << "Sector[" << i << "]: " << (data.data[i] ? "true" : "false");
    // }
    m_PPortLidar->SendEventLidEventTriggered();
    std::this_thread::sleep_for(std::chrono::milliseconds(20));
}

bool Lidar::HandleDeepracerData()
{
    const char* dev = "/dev/ttyUSB0";
    std::uint32_t baudrate = 115200;
    IChannel* channel = *createSerialPortChannel(dev, baudrate);
    ILidarDriver* drv = *createLidarDriver();

    if (!drv) {
        m_logger.LogError() << "Failed to create Lidar driver";
        return false;
    }

    if (SL_IS_OK(drv->connect(channel))) {
        drv->setMotorSpeed();
        drv->startScan(0, 1);

        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        
        while (m_running) {
            sl_lidar_response_measurement_node_hq_t nodes[8192];
            size_t count = sizeof(nodes) / sizeof(nodes[0]);

            if (SL_IS_OK(drv->grabScanDataHq(nodes, count))) {
                drv->ascendScanData(nodes, count);

                std::vector<LidarStruct> scanData;
                saveLidarData(scanData, nodes, count);

                std::vector<float> distances;
                for (const auto& Lstruct : scanData) {
                    distances.push_back(Lstruct.distance);
                }

                auto lidarData = generateLidarData(distances);
                auto sectorLidarData = generateSectorLidarData(lidarData, sectorNum_);

                deepracer::lidardatalist::SectorLidarData convertedSectorData;
                for (const auto& value : sectorLidarData) {
                    convertedSectorData.push_back(value);
                }

                deepracer::serviceinterfacelidar::SectorLidar data;
                data.data = convertedSectorData;
                data.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
                                     std::chrono::system_clock::now().time_since_epoch())
                                     .count();
                data.vehiclemode = toUint16(m_vehicleMode);

                size_t activeSectors = std::count_if(data.data.begin(), data.data.end(), [](bool val) { return val; });
                size_t totalSectors = data.data.size();

                // Log the header information
                m_logger.LogInfo() << "Lidar::Call Lidar->WriteDataLidEvent : "
                                << "Sectors Num : " << activeSectors;

                m_PPortLidar->WriteDataLidEvent(data);
                
                // std::cout << "Data to be sent:" << std::endl;
                // std::cout << "Timestamp: " << data.timestamp << std::endl;
                // for (size_t i = 0; i < data.data.size(); ++i) {
                //     std::cout << "Sector " << i << ": " << data.data[i] << std::endl;
                // }
            }

            m_PPortLidar->SendEventLidEventTriggered();
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }

        drv->stop();
        drv->setMotorSpeed(0);
    }

    delete drv;
    delete channel;
    return true;
}

 
} /// namespace aa
} /// namespace lidar

///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : lidar.cpp
/// SOFTWARE COMPONENT NAME           : Lidar
/// GENERATED DATE                    : 2024-12-03 10:27:57
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "lidar/aa/lidar.h"

using namespace sl;

namespace lidar
{
namespace aa
{
 
Lidar::Lidar()
    : m_logger(ara::log::CreateLogger("LID", "SWC", ara::log::LogLevel::kVerbose)),
      scanIncrementDegree_(0.69),
      minDegree_(-179),
      maxDegree_(171),
      minRange_(150),
      maxRange_(1200),
      sampleNum_(64),
      sectorNum_(8),
      m_workers(1),
      m_running(false)
{
}

 
Lidar::~Lidar()
{
}
 
bool Lidar::Initialize()
{
    m_logger.LogVerbose() << "Lidar::Initialize";
    
    bool init{true};
    
    m_PPortLidar = std::make_shared<lidar::aa::port::PPortLidar>();
    
    return init;
}
 
void Lidar::Start()
{
    m_logger.LogVerbose() << "Lidar::Start";
    
    m_PPortLidar->Start();
    
    // run software component
    Run();
}
 
void Lidar::Terminate()
{
    m_logger.LogVerbose() << "Lidar::Terminate";
    
    m_running = false;

    m_PPortLidar->Terminate();
}
 
void Lidar::Run()
{
    m_logger.LogVerbose() << "Lidar::Run";

    m_running = true;

    m_workers.Async([this] { HandleSectorLidarData(); });

    m_workers.Wait();
}


void Lidar::saveLidarData(std::vector<LidarStruct> &data, sl_lidar_response_measurement_node_hq_t *nodes, size_t count) {
    data.clear();
    for (size_t i = 0; i < count; ++i) {
        LidarStruct Lstruct;
        Lstruct.angle = (nodes[i].angle_z_q14 * 90.f) / 16384.f;
        Lstruct.distance = nodes[i].dist_mm_q2 / 4.0f;
        Lstruct.quality = nodes[i].quality >> SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT;
        data.push_back(Lstruct);

        // printf("Raw Angle: %.2f, Distance: %.2f, Quality: %d",
        //        Lstruct.angle, Lstruct.distance, Lstruct.quality);
        // printf("\n");
    }
}

std::vector<float> Lidar::linspace(float start, float end, float num) {
    if (num <= 0) return {};
    if (num == 1) return {start};

    std::vector<float> linspaced(num);
    float delta = (end - start) / (num - 1);
    for (int i = 0; i < num; ++i) {
        linspaced[i] = start + delta * i;
    }
    return linspaced;
}

std::vector<float> Lidar::interp(const std::vector<float>& sortedX, const std::vector<float>& sortedXp, const std::vector<float>& sortedFp) {
    size_t currXpIdx = 0;
    std::vector<float> returnArray;
    returnArray.reserve(sortedX.size());

    for (size_t currXidx = 0; currXidx < sortedX.size(); ++currXidx) {
        while (currXpIdx < sortedXp.size() - 1 && sortedX[currXidx] > sortedXp[currXpIdx + 1]) {
            ++currXpIdx;
        }
        if (currXpIdx >= sortedXp.size()) break;

        const float percent = (sortedX[currXidx] - sortedXp[currXpIdx]) /
                              (sortedXp[currXpIdx + 1] - sortedXp[currXpIdx]);
        returnArray.push_back(sortedFp[currXpIdx] * (1.0f - percent) + sortedFp[currXpIdx + 1] * percent);
    }
    return returnArray;
}

std::vector<float> Lidar::generateLidarData(const std::vector<float>& distanceList) {
    std::vector<float> lidarRanges, lidarDegrees;
    for (size_t i = 0; i < distanceList.size(); ++i) {
        float degree = minDegree_ + scanIncrementDegree_ * i;
        if (degree >= minDegree_ && degree <= maxDegree_) {
            float range = std::isinf(distanceList[i]) ? maxRange_ : (distanceList[i] < minRange_ ? minRange_ : (distanceList[i] > maxRange_ ? maxRange_ : distanceList[i]));
            lidarRanges.push_back(range);
            lidarDegrees.push_back(degree);
        }
    }

    // printf("Processed Data:\n");
    // for (size_t i = 0; i < lidarRanges.size(); ++i) {
    //     printf("Degree: %.0f, Range: %.2f\n", lidarDegrees[i], lidarRanges[i]);
    // }

    auto desiredLidarDegrees = linspace(minDegree_, maxDegree_, sampleNum_);

    if (std::find(lidarDegrees.begin(), lidarDegrees.end(), minDegree_) == lidarDegrees.end()) {
        lidarDegrees.insert(lidarDegrees.begin(), minDegree_);
        lidarDegrees.push_back(maxDegree_);
        lidarRanges.insert(lidarRanges.begin(), maxRange_);
        lidarRanges.push_back(maxRange_);
    }

    std::lock_guard<std::mutex> guard(lidarMutex_);
    return interp(desiredLidarDegrees, lidarDegrees, lidarRanges);
}

std::vector<float> Lidar::generateSectorLidarData(const std::vector<float>& lidarInput, int sectorNum) {
    size_t blockSize = lidarInput.size() / sectorNum;
    std::vector<float> sectorLidarData = binarySectorizeLidarData(lidarInput, blockSize);

    // printf("Sector Data: ");
    // for (size_t i = 0; i < sectorLidarData.size(); ++i) {
    //     printf("Sector %zu: %.2f; ", i, sectorLidarData[i]);
    // }
    // printf("\n");

    return sectorLidarData;
}


std::vector<float> Lidar::binarySectorizeLidarData(const std::vector<float>& lidarData, size_t blockSize) {
    std::vector<float> sectorLidarData;
    sectorLidarData.reserve((lidarData.size() + blockSize - 1) / blockSize);

    for (size_t i = 0; i < lidarData.size(); i += blockSize) {
        bool setBit = std::any_of(lidarData.begin() + i, lidarData.begin() + std::min(i + blockSize, lidarData.size()),
                                  [this](float value) { return value > minRange_; });
        sectorLidarData.push_back(setBit ? 1.0f : 0.0f);
    }

    return sectorLidarData;
}

bool Lidar::HandleSectorLidarData()
{
    const char* dev = "/dev/ttyUSB0";
    std::uint32_t baudrate = 115200;
    IChannel* channel = *createSerialPortChannel(dev, baudrate);
    ILidarDriver* drv = *createLidarDriver();

    if (!drv) {
        m_logger.LogError() << "Failed to create Lidar driver";
        return false;
    }

    if (SL_IS_OK(drv->connect(channel))) {
        drv->setMotorSpeed();
        drv->startScan(0, 1);

        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        
        while (m_running) {
            sl_lidar_response_measurement_node_hq_t nodes[8192];
            size_t count = sizeof(nodes) / sizeof(nodes[0]);

            if (SL_IS_OK(drv->grabScanDataHq(nodes, count))) {
                drv->ascendScanData(nodes, count);

                std::vector<LidarStruct> scanData;
                saveLidarData(scanData, nodes, count);

                std::vector<float> distances;
                for (const auto& Lstruct : scanData) {
                    distances.push_back(Lstruct.distance);
                }

                auto lidarData = generateLidarData(distances);
                auto sectorLidarData = generateSectorLidarData(lidarData, sectorNum_);

                deepracer::lidardatalist::SectorLidarData convertedSectorData;
                for (const auto& value : sectorLidarData) {
                    convertedSectorData.push_back(value);
                }

                deepracer::serviceinterfacelidar::SectorLidar data;
                data.data = convertedSectorData;
                data.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
                                     std::chrono::system_clock::now().time_since_epoch())
                                     .count();

                size_t activeSectors = std::count_if(data.data.begin(), data.data.end(), [](bool val) { return val; });
                size_t totalSectors = data.data.size();

                // Log the header information
                m_logger.LogInfo() << "Lidar::Call Lidar->WriteDataLidEvent : "
                                << "Sectors Num : " << activeSectors;

                m_PPortLidar->WriteDataLidEvent(data);
                
                // std::cout << "Data to be sent:" << std::endl;
                // std::cout << "Timestamp: " << data.timestamp << std::endl;
                // for (size_t i = 0; i < data.data.size(); ++i) {
                //     std::cout << "Sector " << i << ": " << data.data[i] << std::endl;
                // }
            }

            m_PPortLidar->SendEventLidEventTriggered();
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }

        drv->stop();
        drv->setMotorSpeed(0);
    }

    delete drv;
    delete channel;
    return true;
}

 
} /// namespace aa
} /// namespace lidar

///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : navigation.cpp
/// SOFTWARE COMPONENT NAME           : Navigation
/// GENERATED DATE                    : 2024-12-03 10:27:57
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "navigation/aa/navigation.h"
 
namespace navigation
{
namespace aa
{
 
Navigation::Navigation()
    : m_logger(ara::log::CreateLogger("NAVI", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(2)
    , m_running(false)
{
}
 
Navigation::~Navigation()
{
}
 
bool Navigation::Initialize()
{
    m_logger.LogVerbose() << "Navigation::Initialize";
    
    bool init{true};
    
    m_PPortNavigation = std::make_shared<navigation::aa::port::PPortNavigation>();
    m_RPortInference = std::make_shared<navigation::aa::port::RPortInference>();
    
    return init;
}
 
void Navigation::Start()
{
    m_logger.LogVerbose() << "Navigation::Start";
    
    m_PPortNavigation->Start();
    m_RPortInference->Start();
    
    // run software component
    Run();
}
 
void Navigation::Terminate()
{
    m_logger.LogVerbose() << "Navigation::Terminate";

    m_running = false;

    m_PPortNavigation->Terminate();
    m_RPortInference->Terminate();
}
 
void Navigation::Run()
{
    m_logger.LogVerbose() << "Navigation::Run";

    m_running = true;

    m_workers.Async([this] { TaskReceiveInfEventCyclic(); });
    m_workers.Async([this] { HandleNaviData(); });
    
    m_workers.Wait();
}

void Navigation::TaskReceiveInfEventCyclic()
{
    m_logger.LogInfo() << "TaskReceiveInfEventCyclic: Setting ReceiveEventInfEventHandler";
    m_RPortInference->SetReceiveEventInfEventHandler([this](const auto& sample)
    {
        OnReceiveInfEvent(sample);
    });
    m_RPortInference->ReceiveEventInfEventCyclic();
}

void Navigation::OnReceiveInfEvent(const deepracer::service::inference::proxy::events::InfEvent::SampleType& sample)
{
    m_latestInfData = std::make_shared<deepracer::serviceinterfaceinfer::Inference>(sample);
    m_logger.LogInfo() << "Navigation::OnReceiveInfEvent: Infer data updated.";
    
    if (m_latestInfData) {
        auto timestamp = m_latestInfData->timestamp;
        auto inferData = m_latestInfData->data;

        m_logger.LogInfo() << "Timestamp: " << timestamp;

        for (const auto& item : inferData) {
            m_logger.LogInfo() << "Label : " << item.class_label
                               << ", Prob : " << item.class_prob;
        }
    } else {
        m_logger.LogError() << "No latest infer data available.";
    }
}

void Navigation::HandleNaviData() {
    constexpr std::uint8_t max_retries = 10;
    constexpr std::uint16_t retry_delay_ms = 200;

    while (m_running) {
        std::uint8_t retries = 0;

        while (!m_latestInfData && retries < max_retries) {
            if (retries == 0) {
                m_logger.LogInfo() << "HandleNaviData: Waiting for inference data...";
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(retry_delay_ms));
            ++retries;
        }

        if (!m_latestInfData) {
            m_logger.LogError() << "HandleNaviData: No inference data available after "
                                << max_retries << " retries.";
            continue;
        }

        const auto& inferData = m_latestInfData->data;

        if (inferData.size() < 2) {
            m_logger.LogError() << "HandleNaviData: Insufficient inference data.";
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            continue;
        }

        std::map<int, float> action_values;

        for (const auto& item : inferData) {
            action_values[item.class_label] = clamp(item.class_prob, -1.0f, 1.0f);
        }

        float steering_low = -30.0f;
        float steering_high = 30.0f;
        float speed_low = 1.0f;
        float speed_high = 2.2f;

        float scaled_angle = scale_continuous_value(
            action_values[0], -1.0f, 1.0f, steering_low, steering_high);

        float scaled_throttle = scale_continuous_value(
            action_values[1], -1.0f, 1.0f, speed_low, speed_high);

        deepracer::serviceinterfacecontrol::Control control_data;
        control_data.data.angle = scaled_angle;
        control_data.data.throttle = scaled_throttle;
        control_data.timestamp = m_latestInfData->timestamp;

        m_logger.LogInfo() << "HandleNaviData: Angle = " << scaled_angle
                           << ", Throttle = " << scaled_throttle;

        m_PPortNavigation->WriteDataNavEvent(control_data);
        m_PPortNavigation->SendEventNavEventTriggered();

        m_logger.LogInfo() << "Control Data Sent: "
                           << "Angle = " << control_data.data.angle
                           << ", Throttle = " << control_data.data.throttle
                           << ", Timestamp = " << control_data.timestamp;

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}


float Navigation::clamp(float value, float low, float high) {
    return std::max(low, std::min(value, high));
}

float Navigation::scale_continuous_value(float action, float min_old, float max_old, float min_new, float max_new) {
    if (max_old == min_old) {
        m_logger.LogError() << "scale_continuous_value: Invalid action bounds. Return min_new";
        return min_new;
    }
    return ((max_new - min_new) / (max_old - min_old)) * (action - min_old) + min_new;
}


} /// namespace aa
} /// namespace navigation

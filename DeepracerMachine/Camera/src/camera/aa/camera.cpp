///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : camera.cpp
/// SOFTWARE COMPONENT NAME           : Camera
/// GENERATED DATE                    : 2024-12-03 10:27:56
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "camera/aa/camera.h"

using namespace cv;

namespace camera
{
namespace aa
{

Camera::Camera()
    : m_logger(ara::log::CreateLogger("CAM", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(1)
    , m_running(false)
    , m_vehicleMode(VehicleMode::isDeepRacer)
{
}
 
Camera::~Camera()
{
}
 
bool Camera::Initialize()
{
    m_logger.LogVerbose() << "Camera::Initialize";

    m_PPortCamera = std::make_shared<camera::aa::port::PPortCamera>();

    return true;
}

 
void Camera::Start(VehicleMode mode)
{
    m_logger.LogVerbose() << "Camera::Start";
    
    m_vehicleMode = mode;

    m_PPortCamera->Start();
    
    // run software component
    Run();
}
 
void Camera::Terminate()
{
    m_logger.LogVerbose() << "Camera::Terminate";
    
    m_running = false;

    m_PPortCamera->Terminate();
}
 
void Camera::Run()
{
    m_logger.LogVerbose() << "Camera::Run";
    
    m_running = true;

    m_workers.Async([this] { HandleCamera(); });
    
    m_workers.Wait();
}

bool Camera::HandleCamera()
{
    if (m_vehicleMode == VehicleMode::isSimulation) {
        return HandleSimulationData();
    } else if (m_vehicleMode == VehicleMode::isDeepRacer) {
        return HandleDeepracerData();
    } else {
        m_logger.LogWarn() << "Invalid mode";
        return false;
    }
}

bool Camera::HandleSimulationData()
{
    const std::uint16_t FIXED_WIDTH = 160;
    const std::uint16_t FIXED_HEIGHT = 120;

    camera_sub_l = nh.subscribe<sensor_msgs::Image>(
    "/camera/zed/rgb/image_rect_color", 10,
    [this](const sensor_msgs::Image::ConstPtr& msg) {
        this->cameraCallback(msg, true);
    });

    camera_sub_r = nh.subscribe<sensor_msgs::Image>(
    "/camera/zed_right/rgb/image_rect_color_right", 10,
    [this](const sensor_msgs::Image::ConstPtr& msg) {
        this->cameraCallback(msg, false);
    });

    ROS_INFO("Sensor Data Sender initialized.");

    while (m_running) {
        ros::spinOnce();
        
        cv::Mat left_frame, right_frame;
        cv::Mat left_gray, right_gray;

        if (left_image_buffer && right_image_buffer) {
            left_frame = left_image_buffer->image;
            right_frame = right_image_buffer->image;

            cv::resize(left_frame, left_frame, cv::Size(FIXED_WIDTH, FIXED_HEIGHT));
            cv::resize(right_frame, right_frame, cv::Size(FIXED_WIDTH, FIXED_HEIGHT));

            cv::cvtColor(left_frame, left_gray, cv::COLOR_BGR2GRAY);
            cv::cvtColor(right_frame, right_gray, cv::COLOR_BGR2GRAY);

            deepracer::image::Image LeftCameraData = {FIXED_WIDTH, FIXED_HEIGHT, {}};
            deepracer::image::Image RightCameraData = {FIXED_WIDTH, FIXED_HEIGHT, {}};

            LeftCameraData.data.resize(FIXED_WIDTH * FIXED_HEIGHT);
            RightCameraData.data.resize(FIXED_WIDTH * FIXED_HEIGHT);

            std::memcpy(LeftCameraData.data.data(), left_gray.data, left_gray.total());
            std::memcpy(RightCameraData.data.data(), right_gray.data, right_gray.total());
  
            deepracer::serviceinterfacecam::StereoCamera data;
            data.left = LeftCameraData;
            data.right = RightCameraData;
            data.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
                                 std::chrono::system_clock::now().time_since_epoch())
                                 .count();
            data.vehiclemode = toUint16(m_vehicleMode);

            m_PPortCamera->WriteDataCamEvent(data);

            size_t leftDataSize = data.left.data.size();
            size_t rightDataSize = data.right.data.size();
            size_t totalSize = leftDataSize + rightDataSize;

            m_logger.LogInfo() << "Camera::Call Camera->WriteDataREvent : "
                               << "Left Data Size: " << leftDataSize << " bytes, "
                               << "Right Data Size: " << rightDataSize << " bytes, "
                               << "Total Data Size: " << totalSize << " bytes";

            m_PPortCamera->SendEventCamEventTriggered();
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }
    return true;
}

bool Camera::HandleDeepracerData()
{
    const std::uint16_t FIXED_WIDTH = 160;
    const std::uint16_t FIXED_HEIGHT = 120;

    VideoCapture cap1(0), cap2(2);

    if (!cap1.isOpened() || !cap2.isOpened()) {
        m_logger.LogError() << "Can't open the camera.";
        return false;
    }

    cap1.set(CAP_PROP_FOURCC, VideoWriter::fourcc('M', 'J', 'P', 'G'));
    cap1.set(CAP_PROP_FRAME_WIDTH, FIXED_WIDTH);
    cap1.set(CAP_PROP_FRAME_HEIGHT, FIXED_HEIGHT);

    cap2.set(CAP_PROP_FOURCC, VideoWriter::fourcc('M', 'J', 'P', 'G'));
    cap2.set(CAP_PROP_FRAME_WIDTH, FIXED_WIDTH);
    cap2.set(CAP_PROP_FRAME_HEIGHT, FIXED_HEIGHT);

    std::this_thread::sleep_for(std::chrono::milliseconds(2000));

    while (m_running) {
        for (int i = 0; i < 5; ++i) {
            Mat temp;
            cap1 >> temp;
            cap2 >> temp;
        }

        deepracer::image::Image LeftCameraData = {FIXED_WIDTH, FIXED_HEIGHT, {}};
        deepracer::image::Image RightCameraData = {FIXED_WIDTH, FIXED_HEIGHT, {}};

        LeftCameraData.data.resize(FIXED_WIDTH * FIXED_HEIGHT);
        RightCameraData.data.resize(FIXED_WIDTH * FIXED_HEIGHT);

        Mat frame1, frame2;
        Mat grayFrame1, grayFrame2;

        cap1 >> frame1;
        cap2 >> frame2;

        if (frame1.empty() || frame2.empty()) {
            m_logger.LogError() << "Frame capture failed";
            return false;
        }

        if (frame1.rows != FIXED_HEIGHT || frame1.cols != FIXED_WIDTH ||
            frame2.rows != FIXED_HEIGHT || frame2.cols != FIXED_WIDTH) {
            m_logger.LogError() << "Frame size is different from fixed value";
            return false;
        }

        cvtColor(frame1, grayFrame1, COLOR_BGR2GRAY);
        cvtColor(frame2, grayFrame2, COLOR_BGR2GRAY);

        std::memcpy(LeftCameraData.data.data(), grayFrame1.data, grayFrame1.total());
        std::memcpy(RightCameraData.data.data(), grayFrame2.data, grayFrame2.total());

        deepracer::serviceinterfacecam::StereoCamera data;
        data.left = LeftCameraData;
        data.right = RightCameraData;
        data.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
        data.vehiclemode = toUint16(m_vehicleMode);

        m_PPortCamera->WriteDataCamEvent(data);
        size_t leftDataSize = data.left.data.size();
        size_t rightDataSize = data.right.data.size();
        size_t totalSize = leftDataSize + rightDataSize;

        m_logger.LogInfo() << "Camera::Call Camera->WriteDataREvent : "
                        << "Left Data Size: " << leftDataSize << " bytes, "
                        << "Right Data Size: " << rightDataSize << " bytes, "
                        << "Total Data Size: " << totalSize << " bytes";

        m_PPortCamera->SendEventCamEventTriggered();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    return true;
} 

void Camera::cameraCallback(const sensor_msgs::Image::ConstPtr& msg, bool is_left) {
    cv_bridge::CvImagePtr cv_ptr;

    cv_ptr = cv_bridge::toCvCopy(msg, "bgr8");
    if (cv_ptr) {
        if (is_left) {
            left_image_buffer = cv_ptr;
        } else {
            right_image_buffer = cv_ptr;
        }
    } else {
        ROS_ERROR("Failed to convert ROS Image to OpenCV image");
    }
}


} /// namespace aa
} /// namespace camera

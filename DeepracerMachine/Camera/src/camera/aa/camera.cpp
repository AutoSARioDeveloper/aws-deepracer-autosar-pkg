///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : camera.cpp
/// SOFTWARE COMPONENT NAME           : Camera
/// GENERATED DATE                    : 2024-12-03 10:27:56
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "camera/aa/camera.h"
 
using namespace cv;

namespace camera
{
namespace aa
{

Camera::Camera()
    : m_logger(ara::log::CreateLogger("CAM", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(1)
    , m_running(false)
{
}
 
Camera::~Camera()
{
}
 
bool Camera::Initialize()
{
    m_logger.LogVerbose() << "Camera::Initialize";
    
    bool init{true};
    
    m_PPortCamera = std::make_shared<camera::aa::port::PPortCamera>();
    
    return init;
}
 
void Camera::Start()
{
    m_logger.LogVerbose() << "Camera::Start";
    
    m_PPortCamera->Start();
    
    // run software component
    Run();
}
 
void Camera::Terminate()
{
    m_logger.LogVerbose() << "Camera::Terminate";
    
    m_running = false;

    m_PPortCamera->Terminate();
}
 
void Camera::Run()
{
    m_logger.LogVerbose() << "Camera::Run";
    
    m_running = true;

    m_workers.Async([this] { HandleCameraData(); });
    
    m_workers.Wait();
}

bool Camera::HandleCameraData()
{
    const std::uint16_t FIXED_WIDTH = 160;
    const std::uint16_t FIXED_HEIGHT = 120;

    VideoCapture cap1(0), cap2(2);

    if (!cap1.isOpened() || !cap2.isOpened()) {
        m_logger.LogError() << "Can't open the camera.";
        return false;
    }

    cap1.set(CAP_PROP_FOURCC, VideoWriter::fourcc('M', 'J', 'P', 'G'));
    cap1.set(CAP_PROP_FRAME_WIDTH, FIXED_WIDTH);
    cap1.set(CAP_PROP_FRAME_HEIGHT, FIXED_HEIGHT);

    cap2.set(CAP_PROP_FOURCC, VideoWriter::fourcc('M', 'J', 'P', 'G'));
    cap2.set(CAP_PROP_FRAME_WIDTH, FIXED_WIDTH);
    cap2.set(CAP_PROP_FRAME_HEIGHT, FIXED_HEIGHT);

    std::this_thread::sleep_for(std::chrono::milliseconds(2000));

    while (m_running) {
        for (int i = 0; i < 5; ++i) {
            Mat temp;
            cap1 >> temp;
            cap2 >> temp;
        }

        deepracer::image::Image LeftCameraData = {FIXED_WIDTH, FIXED_HEIGHT, {}};
        deepracer::image::Image RightCameraData = {FIXED_WIDTH, FIXED_HEIGHT, {}};

        LeftCameraData.data.resize(FIXED_WIDTH * FIXED_HEIGHT);
        RightCameraData.data.resize(FIXED_WIDTH * FIXED_HEIGHT);

        Mat frame1, frame2;
        Mat grayFrame1, grayFrame2;

        cap1 >> frame1;
        cap2 >> frame2;

        if (frame1.empty() || frame2.empty()) {
            m_logger.LogError() << "Frame capture failed";
            return false;
        }

        if (frame1.rows != FIXED_HEIGHT || frame1.cols != FIXED_WIDTH ||
            frame2.rows != FIXED_HEIGHT || frame2.cols != FIXED_WIDTH) {
            m_logger.LogError() << "Frame size is different from fixed value";
            return false;
        }

        cvtColor(frame1, grayFrame1, COLOR_BGR2GRAY);
        cvtColor(frame2, grayFrame2, COLOR_BGR2GRAY);

        std::memcpy(LeftCameraData.data.data(), grayFrame1.data, grayFrame1.total());
        std::memcpy(RightCameraData.data.data(), grayFrame2.data, grayFrame2.total());

        deepracer::serviceinterfacecam::StereoCamera data;
        data.left = LeftCameraData;
        data.right = RightCameraData;
        data.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();

        m_PPortCamera->WriteDataCamEvent(data);
        size_t leftDataSize = data.left.data.size();
        size_t rightDataSize = data.right.data.size();
        size_t totalSize = leftDataSize + rightDataSize;

        m_logger.LogInfo() << "Camera::Call Camera->WriteDataREvent : "
                        << "Left Data Size: " << leftDataSize << " bytes, "
                        << "Right Data Size: " << rightDataSize << " bytes, "
                        << "Total Data Size: " << totalSize << " bytes";

        m_PPortCamera->SendEventCamEventTriggered();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    return true;
} 
} /// namespace aa
} /// namespace camera
